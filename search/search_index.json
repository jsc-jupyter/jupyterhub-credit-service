{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JupyterHub Credit Service","text":"<p>The JupyterHub Credit Service is a python package that can be installed as an extension to JupyterHub. It introduces a lightweight, flexible system to limit resource consumption on a per-user and/or per-project model.</p> <p>It enables administrators to control how long users can use computational environments, and how shared project resources are allocated \u2014 all without complex accounting or billing systems.</p>"},{"location":"#overview","title":"Overview","text":"<p>In vanilla JupyterHub deployments administrators can limit the amount of servers a user can spawn with <code>c.JupyterHub.named_server_limit_per_user</code>. This does not take into account what <code>user_options</code> a user has chosen. The JupyterHub Credit Service offers a detailed per-user configuration, depending on the chosen Spawner configurations, with a credit-based quota system:</p> <ul> <li>Each user has a personal maximum amount of credits.</li> <li>Each user gains new credits every <code>n</code> seconds.  </li> <li>Each server consumes credits over time based on its configuration.  </li> <li>Projects can share credits among their members to support community based access restrictions.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install jupyterhub-credit-service\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Example <code>jupyterhub_config.py</code> configuration: <pre><code>import jupyterhub_credit_service\n\n# Configure Authenticator\nfrom oauthenticator.generic import GenericOAuthenticator \n# Use any Authenticator you usually use together with the CreditsAuthenticator\nclass MixinAuthenticator(GenericOAuthenticator, jupyterhub_credit_service.CreditsAuthenticator):\n    pass\n\nc.JupyterHub.authenticator_class = MixinAuthenticator\n\n# Different users may get different amount of credits\ndef user_cap(username, user_groups=[], is_admin=False):\n    if username.endswith(\"mycompany.org\"):\n        return 1000\n    elif username.endswith(\"googlemail.com\") or username.endswith(\"gmail.com\"):\n        return 30\n    return 100\n\nc.MixinAuthenticator.credits_user_cap = user_cap  # may be a callable or integer\nc.MixinAuthenticator.credits_user_grant_value = 5 # may be a callable or integer\nc.MixinAuthenticator.credits_user_grant_interval = 600 # Gain 5 credits every 10 minutes, may be a callable or integer\n\nc.MixinAuthenticator.userinfo_url = ... # your normal configuration\n\n\n# Configure Spawner\nimport kubespawner\n# You can reuse the \"KubeSpawner\" name so you don't have to change your other configs\nclass KubeSpawner(kubespawner.KubeSpawner, jupyterhub_credit_service.CreditsSpawner):\n    pass\n\ndef get_billing_value(spawner):\n    # Costs gpus*10 credits + 5 credits, per billing_interval\n    billing_value = 5\n    if \"gpus\" in spawner.user_options.keys():\n        billing_value += spawner.user_options[\"gpus\"] * 10\n    return billing_value\n\nc.JupyterHub.spawner_class = KubeSpawner\nc.KubeSpawner.billing_value = get_billing_value # may be a callable or integer\nc.KubeSpawner.billing_interval = 600 # Pay credits depending on gpus usage every 10 minutes, may be a callable or integer\n\n\n# Show JupyterHub Credits in the Header in your frontend\nc.JupyterHub.template_paths = jupyterhub_credit_service.template_path\n</code></pre></p>"},{"location":"authenticator/","title":"CreditsAuthenticator","text":"<p>This module forms the core of the JupyterHub Credit Service. At every interval defined by <code>Authenticator.credits_task_interval</code>, the service updates the credit balances for all users. If a user's available credits are insufficient to maintain a running Jupyter server, that server is automatically stopped. This mechanism enables administrators to enforce per-user resource limits and ensure fair usage across the deployment.  </p>"},{"location":"authenticator/#configure-credits-per-user","title":"Configure Credits per User","text":"<p>A user's credit configuration is defined by three main parameters:</p> <ul> <li>credits_user_cap: The maximum number of credits a user can hold. Default: 100</li> <li>credits_user_grant_value: The number of credits granted to a user every <code>credits_user_grant_interval</code> seconds. Default: 10</li> <li>credits_user_grant_interval: The time interval, in seconds, at which users receive their <code>credits_user_grant_value</code> credits. Default: 600</li> </ul> <p>Each of these parameters can be specified either as an integer value or as a callable function that dynamically determines the configuration.</p> <pre><code>async def user_cap(user_name, user_groups, is_admin):\n    if user_name == \"max\":\n        return 150\n    return 100\n\ndef user_grant_value(user_name, user_groups, is_admin):\n    if is_admin:\n        return 20\n    return 10\n\ndef user_grant_interval(user_name, user_groups, is_admin):\n    if \"premium\" in user_groups:\n        return 300  # grant every 5 minutes\n    return 600  # default 10 minutes\n\n# Use callable functions (async or sync), or integer values\nc.CreditsAuthenticator.credits_user_cap = user_cap\nc.CreditsAuthenticator.credits_user_grant_value = user_grant_value\nc.CreditsAuthenticator.credits_user_grant_interval = user_grant_interval\n</code></pre>"},{"location":"authenticator/#configure-projects","title":"Configure Projects","text":"<p>The JupyterHub Credit Service also supports shared credit pools through projects. Projects represent groups or communities that share a collective credit balance. When a user belongs to a project, their usage draws from the project\u2019s credits first, before using their individual credit balance.</p> <p>A project requires a name, along with the same core parameters as the user credit configuration: - cap - grant_value - grant_interval</p> <p>Each user can belong to only one project. To exclude a user from any project, return None or omit the <code>credits_user_project</code> configuration entirely.</p> <p>To configure projects use these parameters: - credits_available_projects: Define a list of available projects a user can be part of. Default: [] - credits_user_project: Callable to define a name of a project a user is part of. Default: None</p> <pre><code>async def available_projects():\n    return [{\n        \"name\": \"community1\",\n        \"cap\": 1000,\n        \"grant_value\": 20,\n        \"grant_interval\": 600,\n    },\n    {\n        \"name\": \"community2\",\n        \"cap\": 500,\n        \"grant_value\": 10,\n        \"grant_interval\": 600,\n    }]\n\nc.CreditsAuthenticator.credits_available_projects = available_projects # List of dicts or a (async) callable\n\ndef credits_user_project(user_name, user_groups, is_admin):\n    if \"community1\" in user_groups:\n        return \"community1\"\n    return None\n\nc.CreditsAuthenticator.credits_user_project = credits_user_project # Must be a callable\n</code></pre>"},{"location":"authenticator/#other-configurations","title":"Other Configurations","text":"<ul> <li> <p>credits_enabled: Enables or disables the credit system entirely. Default: true</p> </li> <li> <p>credits_task_interval: Defines the interval, in seconds, at which the background credit management task executes. Default: 60</p> </li> <li> <p>credits_task_post_hook: An optional callback function executed after each billing interval. Default: None</p> </li> </ul>"},{"location":"authenticator/#implementation-credit-logic","title":"Implementation / Credit Logic","text":"<p>The main process driving the system is the <code>Authenticator.credit_reconciliation_task()</code> function. This background task runs every <code>Authenticator.credits_task_interval</code> seconds and performs the following actions:</p> <ul> <li>Add Project Credits based on project-specific configuration values.  </li> <li>Add User Credits based on user-specific configuration values.  </li> <li>Deduct Project/User Credits for active servers, according to their spawner-specific billing rules.</li> </ul> <p>Whenever <code>Authenticator.add_user</code> (triggered for users not yet registered in JupyterHub) or <code>Authenticator.run_post_auth_hook</code> (typically called during login or authentication refresh) is executed, the user\u2019s configuration is updated. This mechanism ensures that administrators can modify and apply configuration updates for existing users seamlessly.</p>"},{"location":"endpoints/","title":"API Endpoints","text":"<p>The JupyterHub Credit Service exposes two main API endpoints for interacting with user and project credit data. These endpoints allow both users and administrators to monitor and manage credit balances in real time.</p>"},{"location":"endpoints/#user-endpoint","title":"User Endpoint","text":"<p>Path: <code>/hub/api/credits</code> Access: Authenticated users  </p> <p>This endpoint returns the current credit status of the logged-in user, including available balance, cap, and any associated project information.</p>"},{"location":"endpoints/#admin-endpoint","title":"Admin Endpoint","text":"<p>Path: <code>/hub/api/credits/user/&lt;user_name&gt;</code> / <code>/hub/api/credits/project/&lt;project_name&gt;</code> Access: Administrators only  </p> <p>This endpoint allows administrators to adjust user or project credit configurations at runtime. Admin users can update values such as:</p> <ul> <li>balance </li> <li>cap </li> <li>grant_value </li> <li>grant_interval </li> <li>project_name</li> </ul>"},{"location":"endpoints/#typical-use-case","title":"Typical Use Case","text":"<p>If a user or project has exhausted their credits (for example, during a workshop or live session), an administrator can instantly grant additional credits to prevent interruptions.</p>"},{"location":"endpoints/#examples","title":"Examples","text":"<pre><code># Update user credit balance\ncurl -X POST -d '{\"balance\": 100}' \\\n     -H \"Authorization: token $ADMIN_TOKEN\" \\\n     https://_myhub_.com/hub/api/credits/user/user_name\n\n# Update project credit balance\ncurl -X POST -d '{\"balance\": 1000, \"cap\": 1100}' \\\n     -H \"Authorization: token $ADMIN_TOKEN\" \\\n     https://_myhub_.com/hub/api/credits/project/project_name\n</code></pre>"},{"location":"frontend/","title":"Frontend Integration","text":"<p>The JupyterHub Credit Service integrates smoothly with the standard JupyterHub frontend, allowing users to view their current credit balance directly in the interface. If you're using a customized JupyterHub frontend, you can easily include the same functionality. Just check out the changes shown below.</p> <pre><code>from jupyterhub_credit_service import template_path\nc.JupyterHub.template_paths = template_path\n</code></pre> <p>This configuration automatically inserts the user's credit balance into the JupyterHub header. Whenever credits are updated on the server, the displayed balance updates in real time - no manual page refresh required.</p> Click here to see the frontend changes of JupyterHub <pre><code>diff -Naur jupyterhub/page.html jupyterhub_credit_service/page.html\n--- jupyterhub/page.html        2025-10-20 09:03:45.337461368 +0200\n+++ jupyterhub_credit_service/page.html 2025-10-20 09:03:30.204356558 +0200\n@@ -97,6 +97,46 @@                                     \n         xsrf_token: \"{{ xsrf_token }}\",\n       }; \n\n+      {# Connect to CreditsSSEAPIHandler #}\n+      {%- if user %}\n+      var creditsEvtSource = undefined;\n+      function creditsSSEInit() {\n+        let sseUrl = `${jhdata.base_url}api/credits/sse`\n+        if ( jhdata.user ) {\n+            sseUrl = `${jhdata.base_url}api/credits/sse?_xsrf=${window.jhdata.xsrf_token}`;\n+        }                                   \n+        if ( creditsEvtSource ) {            \n+          creditsEvtSource.close();\n+        }                            \n+        creditsEvtSource = new EventSource(sseUrl);\n+        creditsEvtSource.onmessage = (e) =&gt; {\n+          try {                                                                                                              \n+            const jsonData = JSON.parse(event.data);\n+            var htmlText = `Credits: ${jsonData.balance}/${jsonData.cap}`;\n+            if ( jsonData.project ) {\n+              htmlText += ` (${jsonData.project.name}: ${jsonData.project.balance} / ${jsonData.project.cap})`;\n+            }                                 \n+            const span = document.getElementById(\"credits-user\");                                       \n+            span.innerHTML = htmlText;\n+          } catch (error) {\n+              console.error(\"Failed to parse SSE data:\", error);\n+          }\n+        };\n+        creditsEvtSource.onerror = (e) =&gt; {\n+          console.log(\"Reconnect Credits EventSource\");\n+          // Reconnect\n+        }\n+      }\n+      $(document).ready(function() {\n+        creditsSSEInit();\n+      });\n+      window.onbeforeunload = function() {\n+        if (typeof creditsEvtSource !== 'undefined') {\n+            creditsEvtSource.close();\n+        }\n+      }\n+      {%- endif %}\n+\n &lt;/script&gt;\n     {# djlint: on #}\n     {% block meta %}\n@@ -174,6 +214,13 @@\n             &lt;/ul&gt;\n             &lt;ul class=\"nav navbar-nav me-2\"&gt;\n               {% block nav_bar_right_items %}\n+                {% if user %}\n+                &lt;li class=\"nav-item\"&gt;\n+                  &lt;span id=\"credits-user\"\n+                        class=\"me-2\"\n+                        style=\"display: flex; align-items: center;\"/&gt;\n+                &lt;/li&gt;\n+                {% endif %}\n                 &lt;li class=\"nav-item\"&gt;\n                   {% block theme_toggle %}\n                     &lt;button class=\"btn btn-sm\"\n</code></pre>"},{"location":"spawner/","title":"CreditsSpawner","text":"<p>The CreditsSpawner extends the standard JupyterHub Spawner class by introducing a credit-based accounting system for server usage. Each server instance can be assigned a specific credit cost, allowing administrators to define how many credits a user (or their project) must spend to start and maintain a running server.</p> <p>It also prevents server startup when insufficient credits are available, enforcing usage policies in real time.</p>"},{"location":"spawner/#configure-costs-per-spawner","title":"Configure Costs per Spawner","text":"<p>Each spawner can define its own credit consumption model through two key parameters:</p> <ul> <li> <p>billing_value: The number of credits deducted from a user\u2019s (or project\u2019s) account every <code>billing_interval</code> seconds while their server remains active. Default: 10</p> </li> <li> <p>billing_interval: The time interval, in seconds, at which the billing process occurs for a running server. Default: 600</p> </li> </ul> <p>Both parameters can be provided as static integer values or as callable functions that dynamically calculate the configuration at runtime. This flexibility allows administrators to define customized billing rules depending on factors such as server size, resource profile, or user group.</p> <pre><code>def get_billing_value(spawner):\n    values = {\n        \"normal\": 5,\n        \"expensive\": 10,\n    }\n    mode = spawner.user_options.get(\"mode\", \"normal\")\n    return values.get(mode, 5)\n\nc.CreditsSpawner.billing_value = get_billing_value\n\ndef get_billing_interval(spawner):\n    if spawner.user_options.get(\"slowinterval\"):\n        return 1200\n    return 600\n\nc.CreditsSpawner.billing_interval = get_billing_interval\n</code></pre>"},{"location":"spawner/#implementation","title":"Implementation","text":"<p>Within <code>Spawner.run_pre_spawn_hook()</code>, the spawner defines both billing_value and billing_interval for the current server instance. Before the server starts, the system verifies whether the user (or their associated project) has sufficient credits to cover the initial cost.  </p> <p>If the available credits are insufficient, a <code>CreditsException</code> is raised, preventing the server from launching and displaying a clear, informative error message to the user. This ensures that users cannot exceed their allocated credit limits and provides immediate feedback when resources cannot be started due to credit constraints.</p>"},{"location":"spawner/#user-information","title":"User information","text":"<p>The CreditsSpawner shows the required credits and billing interval when starting the Jupyter Server.</p>"}]}